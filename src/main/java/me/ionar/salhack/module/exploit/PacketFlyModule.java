package me.ionar.salhack.module.exploit;

import me.ionar.salhack.events.MinecraftEvent.Era;
import me.ionar.salhack.events.network.EventNetworkPacketEvent;
import me.ionar.salhack.events.player.EventPlayerMotionUpdate;
import me.ionar.salhack.events.player.EventPlayerMove;
import me.ionar.salhack.events.player.EventPlayerPushOutOfBlocks;
import me.ionar.salhack.events.player.EventPlayerTravel;
import me.ionar.salhack.main.SalHack;
import me.ionar.salhack.module.Module;
import me.zero.alpine.fork.listener.EventHandler;
import me.zero.alpine.fork.listener.Listener;
import net.minecraft.network.play.client.CPacketConfirmTeleport;
import net.minecraft.network.play.client.CPacketPlayer;
import net.minecraft.network.play.server.SPacketPlayerPosLook;

public final class PacketFlyModule extends Module
{
    public PacketFlyModule()
    {
        super("PacketFly", new String[]
        { "PacketFly" }, "PacketFly", "NONE", 0xDB248A, ModuleType.EXPLOIT);
    }

    @EventHandler
    private Listener<EventNetworkPacketEvent> PacketEvent = new Listener<>(p_Event ->
    {
        if (p_Event.getPacket() instanceof SPacketPlayerPosLook && mc.currentScreen == null)
        {
            SPacketPlayerPosLook l_Packet = (SPacketPlayerPosLook)p_Event.getPacket();
            
            mc.player.connection.sendPacket(new CPacketConfirmTeleport(l_Packet.getTeleportId()));
            
            mc.player.setPosition(l_Packet.getX(), l_Packet.getY(), l_Packet.getZ());
            
            p_Event.cancel();
        }
    });

    @EventHandler
    private Listener<EventPlayerMotionUpdate> OnPlayerUpdate = new Listener<>(p_Event ->
    {
        if (p_Event.getEra() != Era.PRE)
            return;
        
        p_Event.cancel();
        
        final double l_MaxMotion = 0.03;
        
        /*mc.player.motionX = Math.min(l_MaxMotion, mc.player.motionX);
        mc.player.motionZ = Math.min(l_MaxMotion, mc.player.motionZ);*/
        
        /*if (mc.player.motionX < -l_MaxMotion)
            mc.player.motionX = -l_MaxMotion;
        else if (mc.player.motionX > l_MaxMotion)
            mc.player.motionX = l_MaxMotion;

        if (mc.player.motionZ < -l_MaxMotion)
            mc.player.motionZ = -l_MaxMotion;
        else if (mc.player.motionZ > l_MaxMotion)
            mc.player.motionZ = l_MaxMotion;*/
        
        SalHack.SendMessage("motionX is " + mc.player.motionX + " motionZ is " + mc.player.motionZ);

     //   mc.player.noClip = true;
      //  mc.player.onGround = false;
     //   mc.player.fallDistance = 0;

        if (!mc.player.onGround)
        {
            /*if (mc.player.motionY < -l_MaxMotion)
                mc.player.motionY = -l_MaxMotion;
            else if (mc.player.motionY > l_MaxMotion)
                mc.player.motionY = l_MaxMotion;*/
        }
        
        mc.player.connection.sendPacket(new CPacketPlayer.PositionRotation(mc.player.posX + mc.player.motionX, mc.player.posY + (mc.gameSettings.keyBindJump.isKeyDown() ? 0.0622 : 0) - (mc.gameSettings.keyBindSneak.isKeyDown() ? 0.0622 : 0), mc.player.posZ + mc.player.motionZ, mc.player.rotationYaw, mc.player.rotationPitch, false));
        mc.player.connection.sendPacket(new CPacketPlayer.PositionRotation(mc.player.posX + mc.player.motionX, mc.player.posY - 1337, mc.player.posZ + mc.player.motionZ, mc.player.rotationYaw, mc.player.rotationPitch, true));
    });

    @EventHandler
    private Listener<EventPlayerMove> OnMove = new Listener<>(p_Event ->
    {
        System.out.println("ONMove!");
      //  mc.player.noClip = true;
    });
    
    @EventHandler
    private Listener<EventPlayerPushOutOfBlocks> PushOutOfBlocks = new Listener<>(p_Event ->
    {
        p_Event.cancel();
    });
    
    @Override
    public void onEnable()
    {
        super.onEnable();
      //  mc.player.noClip = true;
    }
    
    @Override
    public void onDisable()
    {
        super.onDisable();
     //   mc.player.noClip = false;
    }
}
